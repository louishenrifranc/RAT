
Les chaines de caractere:

pointeur est a l'adresse &pointeur , a comme valeur une adresse et pointe vers *pointeur
PRINTF:
%f :float
%d :decimal
%u :decimal unsigned
%x :hexa
Option largeur de champs:

var=31337
%u ==> 31337
%3u==> 31337 (rajoute deux octets car 3 ne suffisent pas a afficher var)
%10u==>'      31337'
	^^^^^^
	ajoute 5 octets vides
Pour mettre 0 a la place de ses octets vides, on utilise :%010u:	
					==>0000031337

SCANF
n'attend en argument que des pointeurs, des adresses de variables

Attention si l'on affecte a un int pointeur, un tableau de chaine de caractere,
+ lorsque l'on incremente le pointeur, celui ci decalle l'addresse qu'il sauvegarde
+ de 4 bits (il décalle de la taille du type qu'il est)

Arguments de la ligne de commande:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int main(int arg_count,char *arg[list])

nombre d'arguments
la liste des arguments~

Portee des variables
~~~~~~~~~~~~~~~~~~~~~
Une variable globale est definie en dehors des fonctions
Une variable globale modifié dans une fonction appele dans le main
+modifie pour toutes les fonctions cette variable
+(attention elle doit modifiercette valeur, pas la redefinir)58
++Ce n'est pas le cas des variables locales

Segmentation de la memoire
~~~~~~~~~~~~~~~~~~~~~~~~~~

La memoire d'un programme compilée est divisée en 5 segments:
-segment de texte: contient toutes les instructions assembleur. L'execution n'est pas linéaire
grace aux structures de controle du language de haut niveau traduite en instructions
de branchement, de saut
	Il est en lecture seul.	

-segment de données: contient les variables globales et locales intitialisés.
Celles non initialisée vont dans le:
-bss
Ils sont de taille figés. 
Il ne bougent pas pendant l'execution





!!!!!! Pour le depassement de memoire:
Les variables etant initialises dans cet ordre
int auth_flag
char password[15];
 Elles sont rangees par ordre decroissane de la memoire:ainsi auth_flag est initialise dans la plus haute case memoire
du segment de donnees. En dessous est enregistree password (soit en principe 20 octets en dessous). Ainsi lorsque l'on fait
deborder la taille de password on empiete dans la case memoire de auth_flag... on a fait un depassement de memoire tampon


//J'avais compris ca... tu peux le faire
Un autre moyen est de changer l'adresse de retour d'un bloc d'activation d'une fonction. Imaginons que une fonction renvoit un boolean
tester dans un if et en fonction de cela affiche oui ou non... Dans le bloc d'activation est normalement enregistre l'adrese de retour,si l'on
provoque un suffisament gros depassement de memoire pour modifier l'adresse de retour, alors on peut choisir comme adresse de retour l'adresse de 
l'affichage de oui.




-segment de tas
toutes les variables pour lesquelle on alloue dynamiquement de l'espace (malloc)


-segment de pile: zone de stockage temporaire pour les variables locales des fonctions et le contexte
des appels de fonctions.
Par exemple si une fonction est appele dans un main, la pile va creer une bloc d'activation de la fonction
Ainsi dans la pile est ajoute successivement les parametres passes dans la fonction, la position de retour,
puis ensuite on ajoute sur cette pile toutes les variables locales de la fonction

		GDB
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
gcc -q program.c
gdb -q ./a.out
Lancement du debuggeur

list 1: affiche les dix premieres lignes
break ligne: s'arrete avant la ligne

run argument : lance le programme avec les arguments passées

x/ permet d'examiner une adresse (PAS UNE VARIABLE)
				  ================
#	option x/x 		o 		u		b		s
		hexadecimal	   octal	    decimal  binaire		chaine de caractere
	autre option  w			q
		4octets(mots)		double mot

i r : info registrer

p adresse1 addresse2 :
	calcule la difference entre deux addresses


